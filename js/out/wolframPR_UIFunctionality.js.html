<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: wolframPR/UIFunctionality.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: wolframPR/UIFunctionality.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * UIFunctionality.js
 *
 * Summary:
 *   This script handles all user interface functionality for the simulation. It processes button clicks, user inputs,
 *   mouse actions, and updates to the lattice and cell states. It also manages iterations, simulation modifications,
 *   and communicates with utility files.
 *
 * Features:
 *   - Manages user interactions with the simulation, such as button clicks and mouse actions.
 *   - Updates the lattice and cell configurations based on UI changes.
 *   - Controls iteration flow and updates the display accordingly.
 *   - Interacts with other modules to modify simulation parameters.
 *
 * Functions:
 *   - borderToggleOption(): Toggles the visibility of the border in the simulation.
 *   - startStopToggle(): Toggles the simulation between running and stopped.
 *   - clearResetToggle(): Clears the canvas or resets the simulation state.
 *   - handleCheckboxChange(): Updates the boundary conditions based on checkbox selections.
 *   - makeError(errorMessage, logCanvas, messageQueue): Logs an error message to the message queue.
 *   - makeLog(errorMessage, logCanvas, messageQueue): Logs a standard message to the message queue.
 *   - displayLog(messageQueue, logCanvas): Displays messages from the log queue onto the canvas.
 *   - downloadPDFButton.addEventListener(): Captures the canvas as a PDF and triggers a download.
 *   - downloadPNGButton.addEventListener(): Captures the canvas as a PNG and triggers a download.
 *   - aboutButton.addEventListener(): Displays the about window.
 *   - closeAbout.addEventListener(): Closes the about window.
 *   - optionsButton.addEventListener(): Displays the options window or toggles its visibility.
 *   - closeOptions.addEventListener(): Closes the options window.
 *   - iterationSpeedSlider.oninput: Updates the iteration speed based on slider input.
 *   - debounce(callback): Limits the frequency of function calls, typically used for handling UI input events.
 *   - shortDebounce(callback): A faster debounce function for handling slider inputs.
 *
 * Dependencies:
 *   - latticeArray, rule, canvas, ctx, outputIteration, alterRuleNum, tctx, tickCanvas, logCanvas, drawLattice from './displayLattice.js'
 *   - numOfIterations, currentIteration, size, latSize, ruleNum, inf from './displayLattice.js'
 *   - alterLatSize, alterSize, alterLatticeArray, alterCurrentLattice, alterNextLattice, alterBorder from './displayLattice.js'
 *   - alterRule, alterNumOfIterations, alterCurrentIteration, alterBoundaryCon, alterInf, getBorder from './displayLattice.js'
 *   - updateLattice from './displayLattice.js'
 *   - deadColorSel, aliveColorSel, deadBorderSel, aliveBorderSel from './displayLattice.js'
 *   - ruleNumToRule from './generateLattice.js'
 *   - cell from './cellClass.js'
 *   - logMessage from './logClass.js'
 *
 * Authors:
 *   - Kyle Tranfaglia
 *   - Timmy McKirgan
 *   - Dustin O'Brien
 */

import { latticeArray, rule, canvas, ctx, outputIteration, alterRuleNum, tctx, tickCanvas, logCanvas, drawLattice } from "./displayLattice.js";
import { numOfIterations, currentIteration, size, latSize, ruleNum, inf } from "./displayLattice.js";
import { alterLatSize, alterSize, alterLatticeArray, alterCurrentLattice, alterNextLattice, alterBorder } from "./displayLattice.js";
import { alterRule, alterNumOfIterations, alterCurrentIteration, alterBoundaryCon, alterInf, getBorder } from "./displayLattice.js";
import { updateLattice } from "./displayLattice.js";
import { deadColorSel, aliveColorSel, deadBorderSel, aliveBorderSel } from "./displayLattice.js";
import { ruleNumToRule } from "./generateLattice.js";
import { cell } from "./cellClass.js";
import { logMessage } from "./logClass.js";

/*
Hotkeys for zoom in/out
change cell label when only one row
Reset Perspective Button
*/

/**
 * Variable that detects if mouse is currently down
 * @type {boolean}
 */
let mouseDown = false;

/* Global constants connecting HTML buttons to JS by ID to impliment functionality */

/**
 * Input box for iterations.
 * @type {HTMLInputElement}
 */
const iterationInputBox = document.getElementById("iterationInputBox");

/**
 * Input box for rule input.
 * @type {HTMLInputElement}
 */
const ruleInputBox = document.getElementById("ruleInputBox");

/**
 * Input box for lattice size.
 * @type {HTMLInputElement}
 */
const latticeSizeBox = document.getElementById("latticeSizeBox");

/**
 * Submit button for iterations.
 * @type {HTMLButtonElement}
 */
const iterationSubmit = document.getElementById("iterationSubmit");

/**
 * Submit button for rule input.
 * @type {HTMLButtonElement}
 */
const ruleSubmit = document.getElementById("ruleSubmit");

/**
 * Submit button for lattice size.
 * @type {HTMLButtonElement}
 */
const latticeSizeSubmit = document.getElementById("latticeSizeSubmit");

/**
 * Start/stop button for the simulation.
 * @type {HTMLButtonElement}
 */
const startStopButton = document.getElementById("startStopButton");

/**
 * Iterate button for progressing the simulation.
 * @type {HTMLButtonElement}
 */
const iterateButton = document.getElementById("iterateButton");

/**
 * Clear/reset button for resetting the simulation.
 * @type {HTMLButtonElement}
 */
const clearResetButton = document.getElementById("clearResetButton");

/**
 * Download button for generating PDF.
 * @type {HTMLButtonElement}
 */
const downloadPDFButton = document.getElementById("downloadPDFButton");

/**
 * Download button for generating PNG.
 * @type {HTMLButtonElement}
 */
const downloadPNGButton = document.getElementById("downloadPNGButton");

/**
 * About button for accessing information.
 * @type {HTMLButtonElement}
 */
const aboutButton = document.getElementById("aboutButton");

/**
 * Options button for opening settings.
 * @type {HTMLButtonElement}
 */
const optionsButton = document.getElementById("optionsButton");

/**
 * Button for filling the lattice.
 * @type {HTMLButtonElement}
 */
const latticeFillButton = document.getElementById("latticeFillButton");

/**
 * Button for filling the lattice with random values.
 * @type {HTMLButtonElement}
 */
const randomFillButton = document.getElementById("randomFillButton");

/**
 * Checkbox for periodic boundary conditions.
 * @type {HTMLInputElement}
 */
const periodicCheckBox = document.getElementById("periodicCheckBox");

/**
 * Checkbox for null condition.
 * @type {HTMLInputElement}
 */
const nullCheckBox = document.getElementById("nullCheckBox");

/**
 * Toggle button for boundary conditions.
 * @type {HTMLButtonElement}
 */
const boundToggleButton = document.getElementById("boundToggle");

/**
 * Toggle button for iteration settings.
 * @type {HTMLButtonElement}
 */
const iterationToggleButton = document.getElementById("iterationToggle");

/**
 * Toggle button for border settings.
 * @type {HTMLButtonElement}
 */
const borderToggleButton = document.getElementById("borderToggle");

/**
 * Container window for the About section.
 * @type {HTMLDivElement}
 */
const aboutWindow = document.getElementById("aboutContainer");

/**
 * Container window for the Options section.
 * @type {HTMLDivElement}
 */
const optionsWindow = document.getElementById("optionsContainer");

/**
 * Slider for controlling iteration speed.
 * @type {HTMLInputElement}
 */
const iterationSpeedSlider = document.getElementById("iterationSpeedSlider");

/**
 * Display element showing current iteration speed value.
 * @type {HTMLSpanElement}
 */
const iterationSpeedValue = document.getElementById("iterationSpeedValue");

/**
 * Collection of checkboxes for selecting options.
 * @type {NodeListOf&lt;HTMLInputElement>}
 */
const checkboxes = document.querySelectorAll(".checkbox_select");

/**
 * Button for toggling boundary condition on or off.
 * @type {HTMLButtonElement}
 */
const boundToggle = document.querySelector("#boundToggle .toggle_button");

/**
 * Button for toggling iteration settings on or off.
 * @type {HTMLButtonElement}
 */
const iterationToggle = document.querySelector("#iterationToggle .toggle_button");

/**
 * Button for toggling border settings on or off.
 * @type {HTMLButtonElement}
 */
const borderToggle = document.querySelector("#borderToggle .toggle_button");

/**
 * Close button for the About window.
 * @type {HTMLButtonElement}
 */
const closeAbout = document.querySelector("#aboutContent .close");

/**
 * Close button for the Options window.
 * @type {HTMLButtonElement}
 */
const closeOptions = document.querySelector("#optionsContent .close");

/**
 * Number of iterations to be added.
 * Defaults to 0.
 * @type {number}
 */
let addIterations = 0;

/**
 * Flag to control if the iteration process is running.
 * Defaults to 0 (not running).
 * @type {number}
 */
let run = 0;

/**
 * Time in milliseconds to wait before iterating again.
 * Defaults to 750ms.
 * @type {number}
 */
let iterationTime = 750;

/**
 * Flag to toggle the row ticker.
 * Defaults to 0 (ticker on).
 * @type {number}
 */
let tickerToggle = 0;

/**
 * Scale factor for controlling zoom or scroll level.
 * Defaults to 1.
 * @type {number}
 */
let scale = 1;

/**
 * Total change in scroll position to prevent excessive zooming out.
 * @type {number}
 */
let totalDelta = 0;

/**
 * Queue to store messages for later processing.
 * @type {Array&lt;log>}
 */
let messageQueue = [];

/**
 * redrawLattice
 *
 * Summary:
 *   Redraws the entire lattice array on the canvas by first clearing the canvas
 *   and then filling the grid with the appropriate colors based on the state of each cell.
 *
 * Features:
 *   - Clears the canvas to prepare for redrawing.
 *   - Sets the color for dead cells using the selected color from `deadColorSel`.
 *   - Iterates through each cell in the `latticeArray` and draws it on the canvas.
 *
 * @returns {void} - This function modifies the canvas directly and does not return any value.
 */
function redrawLattice() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = deadColorSel.value;
  ctx.fillRect(latticeArray[0][0].getXLoc(), latticeArray[0][0].getYLoc(), latticeArray[0].length * latticeArray[0][0].getHeight(), latticeArray.length * latticeArray[0][0].getWidth());
  for (let i = 0; i &lt; latticeArray.length; i++) {
    for (let f = 0; f &lt; latticeArray[i].length; f++) {
      latticeArray[i][f].drawCell(ctx);
    }
  }
}

/**
 * inLattice
 *
 * Summary:
 *   Determines if the mouse cursor is currently within the lattice.
 *   Returns `true` if the cursor is inside the lattice bounds, otherwise returns `false`.
 *
 * Features:
 *   - Checks the X position of the mouse relative to the lattice's first and last cells.
 *   - If only one row exists, it directly returns `true` if the mouse's X position is within the lattice.
 *   - If multiple rows exist, it checks both X and Y positions to determine if the mouse is within the lattice.
 *
 * @param {number} mouseX - The X coordinate of the mouse cursor.
 * @param {boolean} [oneRow=true] - Flag indicating if there is only one row in the lattice. Defaults to `true`.
 * @param {number} [mouseY=0] - The Y coordinate of the mouse cursor. Defaults to `0`.
 *
 * @returns {boolean} - `true` if the mouse cursor is within the lattice bounds, `false` otherwise.
 */
function inLattice(mouseX, oneRow = true, mouseY = 0) {
  let inLat = false;
  //If the X position of the mouse is greater then the starting X of the first cell, continue.
  if (mouseX >= latticeArray[0][0].getXLoc()) {
    //If the X position of the mouse is less then the starting X of the last cell plus cell size.
    if (mouseX &lt;= latticeArray[0][latticeArray[0].length - 1].getXLoc() + latticeArray[0][latticeArray[0].length - 1].getWidth()) {
      //If there is only one row, return true for inLattice. Otherwise continue to checking Y position of mouse.
      if (oneRow) {
        inLat = true;
      } else {
        //If the Y position of the mouse is greater than 0 in the canvas, continue.
        if (mouseY >= 0) {
          //If the Y position of the mouse is less then the Y position of the last timestep plus cell size, set inLat to true and return.
          if (mouseY &lt;= latticeArray[latticeArray.length - 1][0].getYLoc() + latticeArray[latticeArray.length - 1][0].getHeight()) {
            inLat = true;
          }
        }
      }
    }
  }
  return inLat;
}

/**
 * revertCells
 *
 * Summary:
 *   Resets the lattice cells to their original, unscrolled form by adjusting
 *   their positions and sizes based on the provided `latSize` and `size`.
 *   The cells are recalculated to fit the original grid layout.
 *
 * Features:
 *   - Adjusts the size and position of each cell in the `latticeArray`.
 *   - Resets each cellâ€™s height, width, and location to reflect the unscrolled state.
 *   - Recalculates the starting position (`startX`) to ensure the lattice is centered.
 *
 * @returns {void} - This function modifies the `latticeArray` directly and does not return any value.
 */
function revertCells() {
  let startX = canvas.width / 2 - (latSize[0] * size) / 2;
  for (let i = 0; i &lt; latticeArray.length; i++) {
    for (let f = 0; f &lt; latticeArray[i].length; f++) {
      latticeArray[i][f].setHeight(size);
      latticeArray[i][f].setWidth(size);
      latticeArray[i][f].setXLoc(startX + f * size);
      latticeArray[i][f].setYLoc(i * size);
    }
  }
}

/**
 * alterCell
 *
 * Summary:
 *   Modifies the position and size of a given cell based on the mouse's location and the scale factor.
 *   The function adjusts the cell's width, height, and position by scaling the distance between the
 *   mouse cursor and the corners of the cell.
 *
 * Features:
 *   - Calculates the new position of the cell based on the mouse cursor's location.
 *   - Adjusts the width and height of the cell according to the scale factor.
 *   - Ensures the cell's new location and dimensions reflect the changes made by the mouse's position.
 *
 * @param {number} mouseX - The X coordinate of the mouse cursor.
 * @param {Object} cell - The cell to be altered. Expected to have methods for getting and setting position, width, and height.
 * @param {number} scale - The scale factor to adjust the cell size and position.
 * @param {number} [mouseY=0] - The Y coordinate of the mouse cursor. Defaults to `0`.
 *
 * @returns {void} - This function modifies the given cell's properties and does not return any value.
 */
function alterCell(mouseX, cell, scale, mouseY = 0) {
  //Get the X and Y position of corner 0 of the cell, the X position of the corner 1 (to the right of corner 0)
  //and the Y position of corner 2 (below corner 0)
  let corner0X = cell.getXLoc();
  let corner0Y = cell.getYLoc();
  let corner1X = cell.getXLoc() + cell.getWidth();
  let corner2Y = cell.getYLoc() + cell.getHeight();

  //Find the corresponding X or Y distance between the current mouse location and the corners.
  let deltaCorner0X = corner0X - mouseX;
  let deltaCorner0Y = corner0Y - mouseY;
  let deltaCorner1X = corner1X - mouseX;
  let deltaCorner2Y = corner2Y - mouseY;

  //Alter the positions by multiplying the ditance between the cursor and the corners by the scale factor
  let newCell0X = mouseX + deltaCorner0X * scale;
  let newCell0Y = mouseY + deltaCorner0Y * scale;
  let newCell1X = mouseX + deltaCorner1X * scale;
  let newCell2Y = mouseY + deltaCorner2Y * scale;

  //Create the new cell width and height
  let newCellWidth = newCell1X - newCell0X;
  let newCellHeight = newCell2Y - newCell0Y;

  //Set new values to the cell.
  cell.setHeight(newCellHeight);
  cell.setWidth(newCellWidth);
  cell.setXLoc(newCell0X);
  cell.setYLoc(newCell0Y);
}

/* THIS SECTION IS USED FOR COLOR PICKING */

/**
 * Event listener for selecting the color for dead cells.
 *
 * Summary:
 *   This function listens for an input event on the `deadColorSel` element (color picker).
 *   When the color is changed, it updates the color of all cells in the lattice by
 *   setting their "dead color" to the selected value. After updating the colors, it redraws
 *   the entire lattice to reflect the change.
 *
 * Features:
 *   - Changes the dead color of all cells in the lattice when a new color is selected.
 *   - Redraws the lattice to apply the updated dead color to all cells.
 *
 * @listens input
 * @param {Event} event - The input event triggered by changing the color in the color picker.
 *
 * @returns {void} - This function does not return any value, it modifies the lattice and redraws it.
 */
deadColorSel.addEventListener("input", function () {
  for (let i = 0; i &lt; latticeArray.length; i++) {
    for (let j = 0; j &lt; latticeArray[0].length; j++) {
      latticeArray[i][j].setDeadColor(deadColorSel.value);
    }
  }
  drawLattice(latticeArray);
});

/**
 * Event listener for selecting the color for alive cells.
 *
 * Summary:
 *   This function listens for an input event on the `aliveColorSel` element (color picker).
 *   When the color is changed, it updates the color of all cells in the lattice by
 *   setting their "alive color" to the selected value. After updating the colors, it redraws
 *   the entire lattice to reflect the change.
 *
 * Features:
 *   - Changes the alive color of all cells in the lattice when a new color is selected.
 *   - Redraws the lattice to apply the updated alive color to all cells.
 *
 * @listens input
 * @param {Event} event - The input event triggered by changing the color in the color picker.
 *
 * @returns {void} - This function does not return any value, it modifies the lattice and redraws it.
 */
aliveColorSel.addEventListener("input", function () {
  for (let i = 0; i &lt; latticeArray.length; i++) {
    for (let j = 0; j &lt; latticeArray[0].length; j++) {
      latticeArray[i][j].setAliveColor(aliveColorSel.value);
    }
  }
  drawLattice(latticeArray);
});

/**
 * Event listener for selecting the border color for dead cells.
 *
 * Summary:
 *   This function listens for an input event on the `deadBorderSel` element (color picker).
 *   When the color is changed, it updates the border color of all cells in the lattice by
 *   setting their "dead border" color to the selected value. After updating the colors, it redraws
 *   the entire lattice to reflect the change.
 *
 * Features:
 *   - Changes the border color of dead cells in the lattice when a new color is selected.
 *   - Redraws the lattice to apply the updated border color to all dead cells.
 *
 * @listens input
 * @param {Event} event - The input event triggered by changing the border color in the color picker.
 *
 * @returns {void} - This function does not return any value, it modifies the lattice and redraws it.
 */
deadBorderSel.addEventListener("input", function () {
  for (let i = 0; i &lt; latticeArray.length; i++) {
    for (let j = 0; j &lt; latticeArray[0].length; j++) {
      latticeArray[i][j].setDeadBorder(deadBorderSel.value);
    }
  }
  drawLattice(latticeArray);
});

/**
 * Event listener for selecting the border color for alive cells.
 *
 * Summary:
 *   This function listens for an input event on the `aliveBorderSel` element (color picker).
 *   When the color is changed, it updates the border color of all cells in the lattice by
 *   setting their "alive border" color to the selected value. After updating the colors, it redraws
 *   the entire lattice to reflect the change.
 *
 * Features:
 *   - Changes the border color of alive cells in the lattice when a new color is selected.
 *   - Redraws the lattice to apply the updated border color to all alive cells.
 *
 * @listens input
 * @param {Event} event - The input event triggered by changing the border color in the color picker.
 *
 * @returns {void} - This function does not return any value, it modifies the lattice and redraws it.
 */
aliveBorderSel.addEventListener("input", function () {
  for (let i = 0; i &lt; latticeArray.length; i++) {
    for (let j = 0; j &lt; latticeArray[0].length; j++) {
      latticeArray[i][j].setAliveBorder(aliveBorderSel.value);
    }
  }
  drawLattice(latticeArray);
});

/**
 * Event listener for zooming in and out on the lattice with mouse wheel scrolling.
 *
 * Summary:
 *   This function listens for a `wheel` event on the `tickCanvas` element. It calculates the
 *   zoom center based on the mouse position, determines whether the lattice has one or more rows,
 *   and adjusts the zoom scale accordingly. It also keeps track of the zoom level using the `totalDelta`
 *   variable and modifies the size and position of cells in the lattice to achieve the zoom effect.
 *   The zoom is either focused on the X-axis for a single row or both X and Y for multiple rows.
 *
 * Features:
 *   - Zooms in and out of the lattice when the mouse wheel is used.
 *   - Calculates the zoom center based on the mouse position to ensure zooming happens around the cursor.
 *   - Adjusts the size and position of cells in the lattice based on the zoom level.
 *   - Limits zooming out by reverting the cell sizes back to their original unzoomed form if needed.
 *
 * @listens wheel
 * @param {WheelEvent} event - The wheel event triggered when the user scrolls with the mouse wheel.
 *
 * @returns {void} - This function does not return any value; it modifies the lattice by adjusting the
 *   scale of the cells and redraws the lattice based on the new scale.
 */
tickCanvas.addEventListener(
  "wheel",
  function (event) {
    let mouseX, mouseY;
    [mouseX, mouseY] = getMouseLocation(event); // Calculates Proper location of zoom center
    //If there is only one row in the lattice and the mouse X position is within the bounds of the lattice (ignoring Y position), continue.
    if (latticeArray.length == 1 &amp;&amp; inLattice(mouseX)) {
      let delta = event.deltaY; //Get delta from mouse scroll.
      //If delta and totalDelta are greater than 0, set scale to 0.9 to zoom out
      if (delta > 0 &amp;&amp; totalDelta > 0) {
        scale = 0.9;
      }
      //If delta is less than 0, set scale to 1.1 to zoom in.
      else if (delta &lt; 0) {
        scale = 1.1;
      }
      totalDelta -= delta; //Subtract delta from totalDelta. This allows us to keep track of how far out the user is zoomed.
      //If totalDelta is less than 0, revert cells to original unzoomed position and set totalDelta to 0.
      if (totalDelta &lt; 0) {
        revertCells();
        totalDelta = 0;
      }
      //Otherwise, alter all of the cells to prepare to draw the zoomed cells.
      else {
        for (let i = 0; i &lt; latticeArray.length; i++) {
          for (let f = 0; f &lt; latticeArray[i].length; f++) {
            alterCell(mouseX, latticeArray[i][f], scale);
          }
        }
      }
      redrawLattice();
    } else if (latticeArray.length > 1 &amp;&amp; inLattice(mouseX, false, mouseY)) {
      let delta = event.deltaY; //Get delta from mouse scroll.
      //If delta and totalDelta are greater than 0, set scale to 0.75 to zoom out. (Zooms more per scroll for effeciency)
      if (delta > 0 &amp;&amp; totalDelta > 0) {
        scale = 0.75;
      }
      //If delta is less than 0, set scale to 1.25 to zoom in. (Zooms more per scroll for effeciency)
      else if (delta &lt; 0) {
        scale = 1.25;
      }
      totalDelta -= delta; //Subtract delta from totalDelta. This allows us to keep track of how far out the user is zoomed.
      //If totalDelta is less than 0, revert cells to original unzoomed position and set totalDelta to 0.
      if (totalDelta &lt; 0) {
        revertCells();
        totalDelta = 0;
      }
      //Otherwise, alter all of the cells to prepare to draw the zoomed cells.
      else {
        for (let i = 0; i &lt; latticeArray.length; i++) {
          for (let f = 0; f &lt; latticeArray[i].length; f++) {
            alterCell(mouseX, latticeArray[i][f], scale, mouseY);
          }
        }
      }
      redrawLattice();
    }
    event.preventDefault();
  },
  false
);

/**
 * Event listener to change the rule set when the submit button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `ruleSubmit` button. When clicked, it stops any ongoing iteration,
 *   clears the reset toggle, and sets the new rule using the current `rule` value.
 *
 * Features:
 *   - Stops the iteration process before applying a new rule to avoid conflicts.
 *   - Clears the reset toggle to ensure that no unintended state persists.
 *   - Sets the new rule to be applied in the lattice simulation.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user when they submit the new rule.
 *
 * @returns {void} - This function does not return any value; it modifies the lattice simulation by stopping
 *   iteration, clearing the reset toggle, and setting the new rule.
 */
ruleSubmit.addEventListener("click", function () {
  stopIterating(); // Stops the iteration before changing the rule number
  clearResetToggle();
  setRule(rule);
});

/**
 * Event listener to fill the lattice with all alive cells when the button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `latticeFillButton`. When clicked, it stops any ongoing iteration,
 *   resets the lattice, and sets all cells in the first row of the lattice to the alive state. It also logs the action.
 *
 * Features:
 *   - Stops the iteration process to ensure changes are applied without interference.
 *   - Resets the lattice size and clears any previous states.
 *   - Sets all cells in the first row of the lattice to alive.
 *   - Draws the updated lattice on the canvas.
 *   - Logs the action in the message queue for later reference.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to fill the lattice.
 *
 * @returns {void} - This function does not return any value; it modifies the lattice by filling it with alive cells
 *   and logging the action.
 */
latticeFillButton.addEventListener("click", function () {
  stopIterating(); // Stops the iteration before completely filling the lattice
  clearResetToggle();
  setLatticeSize();
  clear(latticeArray);
  for (let i = 0; i &lt; latticeArray[0].length; i++) {
    latticeArray[0][i].setColor(1);
  }
  drawLattice(latticeArray);
  makeLog("Filled Lattice", logCanvas, messageQueue);
});

/**
 * Event listener to randomly set the state of all cells in the starting lattice when the button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `randomFillButton`. When clicked, it stops any ongoing iteration,
 *   resets the lattice, and randomly assigns a state (either alive or dead) to each cell in the first row of the lattice.
 *   The action is logged for future reference.
 *
 * Features:
 *   - Stops the iteration process to ensure the random filling occurs without interference.
 *   - Resets the lattice size and clears any previous states.
 *   - Randomly assigns the state (alive or dead) to each cell in the first row of the lattice.
 *   - Draws the updated lattice on the canvas.
 *   - Logs the action in the message queue for later reference.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to randomly fill the lattice.
 *
 * @returns {void} - This function does not return any value; it modifies the lattice by randomly setting cell states
 *   and logs the action.
 */
randomFillButton.addEventListener(
  "click",
  debounce(function () {
    stopIterating(); // Stops the iteration before randomly filling the lattice
    clearResetToggle();
    setLatticeSize();
    clear(latticeArray);
    for (let i = 0; i &lt; latticeArray[0].length; i++) {
      latticeArray[0][i].setColor(Math.floor(Math.random() * 2));
    }
    drawLattice(latticeArray);
    makeLog("Randomized Lattice", logCanvas, messageQueue);
  })
);

/**
 * Event listener to handle iteration of lattice cells when the iterate button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `iterateButton`. When clicked, it stops any ongoing iteration,
 *   alters the lattice to account for buffer cells, adjusts the lattice size, and iterates the lattice based on the
 *   inputted number of iterations. The action and any errors are logged.
 *
 * Features:
 *   - Stops the iteration process before starting a new iteration.
 *   - Adds buffer cells on both ends of the lattice for a "mock" array to simulate new iterations.
 *   - Adjusts the lattice size and cell size to fit the new lattice, capped at a maximum size of 45.
 *   - Iterates through the lattice array, applying the rule and altering cell colors accordingly.
 *   - Logs the iteration action or error messages (if the iteration number is not set).
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to iterate the lattice.
 *
 * @returns {void} - This function does not return any value. It performs actions on the lattice based on the
 *   iteration number and the input values, and logs the corresponding messages.
 */
iterateButton.addEventListener(
  "click",
  debounce(function () {
    stopIterating(); // Stops the iteration before doing a complete iteration
    //Keep infinite the same and add the buffers
    alterInf(inf[0], true);
    console.log(addIterations);
    if (addIterations == 0) {
      makeError("Iteration not set", logCanvas, messageQueue);
      return;
    }
    makeLog("Iterated to " + addIterations + " Rule: " + ruleNum, logCanvas, messageQueue);
    if (latticeArray.length == 1) {
      let bufferArr = new Array();
      let latPlusBufferArr = new Array();
      //Store current cell states
      for (let i = 0; i &lt; latSize[0]; i++) {
        latPlusBufferArr.push(latticeArray[0][i].getColor());
      }
      //Add buffer cells on either one for the mock array.
      for (let i = 0; i &lt; latSize[1]; i++) {
        bufferArr.push(0);
      }
      latPlusBufferArr = bufferArr.concat(latPlusBufferArr.concat(bufferArr));
      //Change the lattice size to include the buffers.
      let newCellNum = latSize[0] + 2 * latSize[1];
      if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1) {
        alterLatSize(newCellNum);
      }
      //Change size to accomodate new lattice size.
      let size = canvas.width / latSize[0];
      //Cells should have a maximum size of 45 :: This Caps cell size to 45
      if (size > 45) {
        size = 45;
      }
      alterSize(size);
      //Clear lattice array to generate new lattice of appropriate size.
      clear(latticeArray);
      let neoLatticeArray = latticeArray;
      //Iterate through lattice array and use mock array to change colors appropriately.
      for (let i = 0; i &lt; latticeArray[0].length; i++) {
        if (latPlusBufferArr[i] == 1) {
          neoLatticeArray[0][i].flipColor();
        }
        neoLatticeArray[0][i].drawCell(ctx);
        alterLatticeArray(neoLatticeArray);
      }
      clearResetButton.innerHTML = "Reset";
    }
    iterate(currentIteration, addIterations);
  })
);

/**
 * Event listener to handle clearing the lattice and resetting the canvas when the clear/reset button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `clearResetButton`. When clicked, it stops any ongoing iteration,
 *   removes buffer cells if they exist, adjusts the lattice size and cell size accordingly, and clears the lattice.
 *   The action is logged, and errors are reported if the lattice size is invalid.
 *
 * Features:
 *   - Stops the iteration process before starting the clearing/resetting process.
 *   - Removes any buffer cells from the lattice and adjusts its size to reflect this change.
 *   - Resizes the cells to fit the new lattice dimensions, with a maximum size cap of 45.
 *   - Clears the lattice array, either with or without buffer cells, depending on the lattice's structure.
 *   - Logs the action and displays an error message if the new lattice size is invalid.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to clear or reset the lattice.
 *
 * @returns {void} - This function performs actions to clear or reset the lattice, adjusts the size of the lattice and cells,
 *   and logs corresponding messages.
 */
clearResetButton.addEventListener(
  "click",
  debounce(function () {
    stopIterating(); // Stops the iteration before changing clearing the canvas
    clearResetToggle();

    // Removes buffers if they existed.
    let newCellNum = latSize[0] - 2 * latSize[1];
    if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
      alterLatSize(newCellNum);
    } else {
      makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
    }
    // Alters size of cells to accomodate for removed cells.
    let size = canvas.width / latSize[0];
    // Cells should have a maximum size of 45 :: This Caps cell size to 45
    if (size > 45) {
      size = 45;
    }
    alterSize(size);
    if (latticeArray.length == 1) {
      clear(latticeArray);
    } else {
      clear(latticeArray, true);
    }
    alterInf(inf[0], false);
  })
);

/* Connect UI Functionality to a prebuilt function */

/**
 * Event listener to handle toggling the boundary condition when the boundary toggle button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `boundToggleButton`. When clicked, it stops any ongoing iteration,
 *   and toggles the boundary condition by calling the `toggleCheckbox()` function.
 *
 * Features:
 *   - Stops the iteration process before toggling the boundary condition to prevent interference.
 *   - Toggles the state of the boundary condition via a checkbox.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to toggle the boundary condition.
 *
 * @returns {void} - This function stops the iteration and triggers the boundary condition toggle.
 */
boundToggleButton.addEventListener(
  "click",
  debounce(function () {
    stopIterating(); // Stops the iteration before changing the boundary condition
    toggleCheckbox();
  })
);

/**
 * Event listener to handle toggling the iteration state when the iteration toggle button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `iterationToggleButton`. When clicked, it toggles the state of
 *   `tickerToggle`, clears the `tickCanvas`, and updates the iteration toggle option by calling `iterationToggleOption()`.
 *
 * Features:
 *   - Toggles the state of `tickerToggle`, which likely controls the running of iterations.
 *   - Clears the `tickCanvas` to reset the displayed canvas before performing further operations.
 *   - Calls `iterationToggleOption()` to adjust the system's state based on the new `tickerToggle` value.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to toggle iteration state.
 *
 * @returns {void} - This function toggles the iteration state and clears the canvas to reset the display.
 */
iterationToggleButton.addEventListener(
  "click",
  debounce(function () {
    tickerToggle = !tickerToggle;
    tctx.clearRect(0, 0, tickCanvas.width, tickCanvas.height);
    iterationToggleOption();
  })
);

/**
 * Event listener to handle toggling the border visibility when the border toggle button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `borderToggleButton`. When clicked, it toggles the border visibility
 *   by calling `alterBorder()` with the opposite of the current border state, redraws the lattice, and updates the
 *   border toggle option by calling `borderToggleOption()`.
 *
 * Features:
 *   - Toggles the border visibility using `alterBorder()` by passing the inverse of the current border state.
 *   - Redraws the lattice using `drawLattice()` to reflect the updated border state.
 *   - Calls `borderToggleOption()` to adjust the system's state based on the new border visibility.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to toggle the border visibility.
 *
 * @returns {void} - This function toggles the border state, redraws the lattice, and updates the border toggle option.
 */
borderToggleButton.addEventListener(
  "click",
  debounce(function () {
    alterBorder(!getBorder());
    drawLattice(latticeArray);
    borderToggleOption();
  })
);

/**
 * Event listener to handle submitting the iteration count when the iteration submit button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `iterationSubmit` button. When clicked, it stops the current iteration
 *   process using `stopIterating()`, and then calls `setLatticeSize()` to potentially adjust or reset the lattice size.
 *
 * Features:
 *   - Stops the current iteration process by calling `stopIterating()`.
 *   - Adjusts or resets the lattice size based on the new input by calling `setLatticeSize()`.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to submit the iteration count.
 *
 * @returns {void} - This function stops the iteration process and potentially resets the lattice size.
 */
iterationSubmit.addEventListener("click", function () {
  stopIterating(); // Stops the iteration before changing the iteration amount
  setLatticeSize();
});

/**
 * Event listener to handle submitting the lattice size when the lattice size submit button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `latticeSizeSubmit` button. When clicked, it stops the current iteration
 *   process using `stopIterating()`, clears any reset toggle states, and then updates the lattice size on the canvas
 *   by calling `updateLatticeSize(canvas)`.
 *
 * Features:
 *   - Stops the current iteration process by calling `stopIterating()`.
 *   - Clears any active reset toggle state.
 *   - Updates the lattice size by calling `updateLatticeSize(canvas)` to adjust the grid.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to submit the new lattice size.
 *
 * @returns {void} - This function stops the iteration, clears reset toggle state, and updates the lattice size.
 */
latticeSizeSubmit.addEventListener("click", function () {
  stopIterating(); // Stops the iteration before changing the lattice size
  clearResetToggle();
  updateLatticeSize(canvas);
});

/**
 * Event listener to toggle the start/stop of the iteration process when the start/stop button is clicked.
 *
 * Summary:
 *   This function listens for a `click` event on the `startStopButton`. When clicked, it toggles between starting
 *   and stopping the iteration process. If the iteration has not been set, it displays an error. If the iteration
 *   is stopped, it starts the iteration, updating the lattice size and handling buffer cells. If the iteration is already
 *   running, it stops the iteration and toggles the button state.
 *
 * Features:
 *   - Checks if the number of iterations has been set, and displays an error message if not.
 *   - Toggles between starting and stopping the iteration process.
 *   - Adds buffer cells to the lattice for proper iteration when the lattice size is 1.
 *   - Adjusts the lattice size to accommodate the buffers and ensures cells do not exceed a maximum size.
 *   - Calls `continouslyIterate(iterationTime)` to start the iteration process.
 *
 * @listens click
 * @param {MouseEvent} event - The click event triggered by the user to start or stop the iteration.
 *
 * @returns {void} - This function toggles the iteration process and updates the lattice state accordingly.
 */
startStopButton.addEventListener(
  "click",
  debounce(function () {
    if (addIterations == 0) {
      makeError("Iteration not set", logCanvas, messageQueue);
      return;
    }
    if (run != 1) {
      run = 1;
      startStopToggle();
      if (latticeArray.length == 1) {
        let bufferArr = new Array();
        let latPlusBufferArr = new Array();
        //Store current cell states
        for (let i = 0; i &lt; latSize[0]; i++) {
          latPlusBufferArr.push(latticeArray[0][i].getColor());
        }
        //Add buffer cells on either one for the mock array.
        for (let i = 0; i &lt; latSize[1]; i++) {
          bufferArr.push(0);
        }
        latPlusBufferArr = bufferArr.concat(latPlusBufferArr.concat(bufferArr));
        //Change the lattice size to include the buffers.
        let newCellNum = latSize[0] + 2 * latSize[1];
        if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1) {
          alterLatSize(newCellNum);
        }
        //Change size to accomodate new lattice size.
        let size = canvas.width / latSize[0];
        //Cells should have a maximum size of 45 :: This Caps cell size to 45
        if (size > 45) {
          size = 45;
        }
        alterSize(size);
        //Clear lattice array to generate new lattice of appropriate size.
        clear(latticeArray);
        let neoLatticeArray = latticeArray;
        //Iterate through lattice array and use mock array to change colors appropriately.
        for (let i = 0; i &lt; latticeArray[0].length; i++) {
          if (latPlusBufferArr[i] == 1) {
            neoLatticeArray[0][i].flipColor();
          }
          neoLatticeArray[0][i].drawCell(ctx);
          alterLatticeArray(neoLatticeArray);
        }
        if (addIterations) {
          clearResetButton.innerHTML = "Reset";
        }
      }
      continouslyIterate(iterationTime);
    } else {
      run = 0;
      startStopToggle();
    }
  })
);

/**
 * Event listener to continuously track the mouse position on the canvas and update the tick box position.
 *
 * Summary:
 *   This function listens for a `mousemove` event on the `tickCanvas`. It tracks the mouse position within the canvas
 *   and updates the position of a tick box next to it, allowing users to interact with the tick box dynamically.
 *
 * Features:
 *   - Tracks the mouse position on the canvas.
 *   - Calls `makeTickBox(event, tctx)` to render the tick box at the current mouse position.
 *
 * @listens mousemove
 * @param {MouseEvent} event - The mousemove event triggered by the user to track the mouse position.
 *
 * @returns {void} - This function updates the tick box position based on the mouse location.
 */
tickCanvas.addEventListener("mousemove", function (event) {
  makeTickBox(event, tctx);
});

/**
 * Event listener to flip cells when the user clicks on the canvas.
 *
 * Summary:
 *   This function listens for a `mousedown` event on the `tickCanvas`. When the user clicks on the canvas, it calculates
 *   the mouse position and flips the state of the cell that was clicked. It also disables text selection globally during the
 *   mouse interaction to improve user experience.
 *
 * Features:
 *   - Disables text selection to prevent accidental text highlighting during interaction.
 *   - Tracks the mouse position using `getMouseLocation(event)`.
 *   - Calls `setCells(latticeArray, mouseX, mouseY)` to flip the cell that the mouse clicked on.
 *
 * @listens mousedown
 * @param {MouseEvent} event - The mousedown event triggered by the user when clicking on the canvas.
 *
 * @returns {void} - This function flips the state of the cell that was clicked and prevents text selection.
 */

tickCanvas.addEventListener(
  "mousedown",
  debounce(function (event) {
    document.body.style.userSelect = "none"; // Disable text selection globally
    let mouseX, mouseY;
    [mouseX, mouseY] = getMouseLocation(event); // Calculates Proper location of mouse click for usage in setCells
    setCells(latticeArray, mouseX, mouseY); // Flips the cell if it was clicked on
    mouseDown = true;
  })
);

tickCanvas.addEventListener("mouseup", function (event) {
  mouseDown = false;
});

tickCanvas.addEventListener(
  "mousemove",
  shortDebounce(function (event) {
    let mouseX, mouseY;
    if (mouseDown) [mouseX, mouseY] = getMouseLocation(event);
    setCells(latticeArray, mouseX, mouseY, true);
  })
);

/**
 * Event listener that handles keyboard shortcuts when a key is pressed.
 *
 * Summary:
 *   This function listens for a `keydown` event and checks for specific key combinations or individual key presses.
 *   It allows the user to trigger various actions (such as clicking buttons or focusing input fields) via keyboard shortcuts.
 *   If the ALT key is pressed, it executes predefined actions associated with other keys. If the Enter key is pressed,
 *   it submits the active input field.
 *
 * Features:
 *   - Supports ALT key combinations for quick actions (e.g., starting/stopping iterations, clearing/resetting buttons).
 *   - Focuses specific input fields when the corresponding keys (e.g., "j", "k", "l", "y") are pressed.
 *   - Toggles visibility for a specific element with the "Dustin" class when the "=" key is pressed.
 *   - Submits forms based on the currently focused input field when the Enter key is pressed.
 *
 * @listens keydown
 * @param {KeyboardEvent} event - The keydown event triggered by the user when pressing a key on the keyboard.
 *
 * @returns {void} - This function performs actions like button clicks, element visibility toggling, and form submissions.
 */
document.addEventListener("keydown", function (event) {
  // Check if ALT key is pressed, then check if another key is pressed and complete corresponding action
  if (event.altKey) {
    switch (true) {
      case event.key == "Enter":
        startStopButton.click();
        break;
      case event.key == "i":
        iterateButton.click();
        break;
      case event.key == "c":
        clearResetButton.click();
        break;
      case event.key == "o":
        optionsButton.click();
        break;
      case event.key == "a":
        aboutButton.click();
        break;
      case event.key == "n":
        downloadPDFButton.click();
        break;
      case event.key == "p":
        downloadPNGButton.click();
        break;
      case event.key == "g":
        latticeFillButton.click();
        break;
      case event.key == "m":
        randomFillButton.click();
        break;
      case event.key == "u":
        boundToggleButton.click();
        break;
      case event.key == "w":
        iterationToggleButton.click();
        break;
      case event.key == "x":
        borderToggleButton.click();
        break;
      case event.key == "j":
        iterationInputBox.focus();
        break;
      case event.key == "k":
        ruleInputBox.focus();
        break;
      case event.key == "l":
        latticeSizeBox.focus();
        break;
      case event.key == "y":
        iterationSpeedSlider.focus();
        break;
      case event.key == "=":
        let dustin = document.querySelector(".Dustin");
        if (dustin.style.display == "block") {
          dustin.style.display = "none";
        } else {
          dustin.style.display = "block";
        }
        break;
      default:
        break;
    }
    // Enter key clicked, check if an inputbox is active and click submit for that box
  } else if (event.key == "Enter") {
    if (document.activeElement == iterationInputBox) {
      iterationSubmit.click();
    } else if (document.activeElement == ruleInputBox) {
      ruleSubmit.click();
    } else if (document.activeElement == latticeSizeBox) {
      latticeSizeSubmit.click();
    } else {
      iterationSubmit.click();
      ruleSubmit.click();
      latticeSizeSubmit.click();
    }
  }
});

// function updateLatticeSize() {
// 	alterLatSize(setCellNum(latSize)); //updates latSize to no latSize

// 	//Sets cells to maximize usage of the canvas
// 	alterSize(canvas.width / latSize);
// 	//Cells should have a maximum size of 45
// 	if (size > 45){
// 		alterSize(45);
// 	}

// 	clear(latticeArray, canvas);
// }

/**
 * Updates the number of cells in a lattice and resizes the cells accordingly.
 *
 * Summary:
 *   This function adjusts the lattice size based on user input, ensuring that the number of cells
 *   is within a valid range (1 to 1000). It then resizes the individual cells on the canvas, capping
 *   the cell size to a maximum of 45 pixels. After updating the size, it clears the lattice array
 *   and redraws the lattice on the canvas.
 *
 * Features:
 *   - Accepts user input for the number of cells and ensures it's valid.
 *   - Resizes the individual cells on the canvas based on the new lattice size.
 *   - Limits cell size to a maximum of 45 pixels.
 *   - Clears the current lattice array and redraws the lattice with updated dimensions.
 *
 * @param {HTMLCanvasElement} canvas - The canvas element used to draw the lattice.
 * @returns {void} - This function does not return any value. It performs size updates and canvas redrawing.
 */
function updateLatticeSize(canvas) {
  let newCellNum = parseInt(latticeSizeBox.value);

  if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
    alterLatSize(newCellNum);
    makeLog("Lattice Size Set to " + newCellNum, logCanvas, messageQueue);
  } else {
    makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
  }

  let size = canvas.width / latSize[0];

  //Cells should have a maximum size of 45 :: This Caps cell size to 45
  if (size > 45) {
    size = 45;
  }

  alterSize(size);
  alterInf(inf[0], false);

  clear(latticeArray); //emptys out canvas and redraws
}

/**
 * Generates and displays a tick box at the mouse location on the canvas.
 *
 * Summary:
 *   This function calculates the position of the mouse on the lattice, determines if the mouse
 *   is inside a valid cell, and if so, generates a tick box showing the row and column of the cell
 *   under the mouse. The tick box is drawn on a separate canvas (`tickCanvas`), and its position
 *   is adjusted based on the mouse's location. The function ensures that the text and box are drawn
 *   only if the mouse is within valid boundaries of the lattice.
 *
 * Features:
 *   - Tracks mouse position and checks if it's inside the lattice bounds.
 *   - Displays a tick box with the row and column number at the mouse's location.
 *   - Adjusts text size and background for visibility.
 *   - Ensures that the tick box is only drawn if the mouse is inside a valid lattice cell.
 *
 * @param {MouseEvent} event - The mouse event triggered by the mousemove on the canvas, used to calculate mouse location.
 * @returns {void} - This function does not return any value. It updates the tick box displayed on the canvas.
 */
function makeTickBox(event) {
  if (tickerToggle == 1) {
    let [mouseX, mouseY] = getMouseLocation(event); //Gets the mouse Location

    let firstCell = latticeArray[0][0];

    tctx.clearRect(0, 0, tickCanvas.width, tickCanvas.height);

    let lineNumber = Math.floor(mouseY / firstCell.getHeight()); //calculates what line your on
    let colNumber = Math.floor((mouseX - firstCell.getXLoc()) / firstCell.getWidth());

    let insideBox = true;

    if (colNumber &lt; 0) {
      insideBox = false;
    }

    if (colNumber > latticeArray[0].length - 1) {
      insideBox = false;
    }

    if (lineNumber > latticeArray.length - 1) {
      insideBox = false;
    }

    if (lineNumber &lt; 0) {
      insideBox = false;
    }

    //drawLattice(latticeArray);
    if (insideBox) {
      let tickNum = lineNumber.toString() + " : " + colNumber.toString();

      let textSize = tctx.measureText(tickNum).width;

      if (textSize &lt; 30) {
        textSize = 30;
      }

      tctx.fillStyle = "grey";
      tctx.fillRect(mouseX + 3, mouseY - 12, textSize + 3, 15); //Draws the Tick Box square

      //Sets text specifications
      tctx.font = "13px Arial";
      tctx.fillStyle = "black";

      tctx.fillText(tickNum, mouseX + 4, mouseY); //Puts the text in place
    }
  }
}

/**
 * Sets the delay time between iterations when running the lattice.
 *
 * Summary:
 *   This function adjusts the delay time between each iteration of the lattice. It updates
 *   the `iterationTime` variable, which controls how frequently the lattice is updated. This is
 *   useful for controlling the speed at which the lattice iterates.
 *
 * @param {number} newDelay - The new delay time in milliseconds to set for the iterations.
 * @returns {void} - This function does not return any value. It modifies the global `iterationTime` variable.
 */
function setDelay(newDelay) {
  iterationTime = newDelay;
}

/**
 * Repeatedly iterates through the lattice while the `run` flag is true.
 *
 * Summary:
 *   This function continuously performs iterations on the lattice at a set interval, defined
 *   by the `iterationTime` parameter. It checks if the `run` flag is true, and if so, it calls
 *   the `iterate` function to perform an iteration. This process repeats indefinitely until `run`
 *   is set to false, at which point it stops the iterations and toggles the start/stop state.
 *
 * @param {number} iterationTime - The time delay between iterations in milliseconds.
 * @returns {void} - This function does not return any value. It modifies the flow of execution
 *                   through recursive calls and controls the iteration cycle.
 */
function continouslyIterate(iterationTime) {
  //Checks if Run is activate
  if (run) {
    setTimeout(function () {
      // puts a wait before iterating again
      if (run) {
        iterate(currentIteration, 1); //iterates the number of lattices
      }
      continouslyIterate(iterationTime); // allows it to coninously run by calling it again
    }, iterationTime);
  } else {
    startStopToggle(currentIteration);
  }
}

/**
 * Sets the rule for the lattice based on user input and updates the lattice configuration.
 *
 * Summary:
 *   This function takes the value from the rule input box, converts it to an integer, and
 *   checks if it's within the valid range (0-255). If the input is valid, it updates the rule,
 *   adjusts the lattice size by removing buffers if necessary, and re-renders the lattice with
 *   the new configuration. If the input is invalid, an error message is displayed.
 *
 * @returns {void} - This function does not return a value. It modifies the lattice size, rule,
 *                   and other related properties based on the user input.
 */
function setRule() {
  let newRule = parseInt(ruleInputBox.value); //Turns input in rule input box into a number
  run = 0; //Tells continous to not run
  //Checks if integer was a real integer and if its in the required range of the function
  if (!isNaN(newRule) &amp;&amp; newRule >= 0 &amp;&amp; newRule &lt;= 255) {
    alterRuleNum(newRule);
    alterRule(ruleNumToRule(newRule));
    makeLog("Rule Set to " + newRule, logCanvas, messageQueue);

    //Removing buffers if they existed
    let newCellNum = latSize[0] - 2 * latSize[1];
    if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
      alterLatSize(newCellNum);
    } else {
      makeError("Invalid Rule Number: " + latticeSizeBox.value, logCanvas, messageQueue);
    }
    //Changing size of cells fo accomodate for removed buffers.
    let size = canvas.width / latSize[0];
    //Cells should have a maximum size of 45 :: This Caps cell size to 45
    if (size > 45) {
      size = 45;
    }
    alterSize(size);
    //Alter the infinite array to keep the Infinite setting as is but remove buffers.
    alterInf(inf[0], false);
    clear(latticeArray, true);
  } else {
    makeError("Invalid Rule Number: " + ruleInputBox.value, logCanvas, messageQueue);
  }
}

//Sets new number of cells in a lattice
/*function setCellNum(latSize) {
	let newCellNum = parseInt(latticeSizeBox.value); //Turns Input box input into a number
	if(!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) //Tests if input was truly an integer and then makes sure it was in the range of 1 and 1000 to make sure not too big
	{
		latSize = newCellNum;
	} //updates the new cell number
	else
	{
	} //outputs the error to console currently

	return latSize; //returns the new lattice Size
}*/

/**
 * Sets the number of iterations for the lattice and adjusts the lattice size accordingly.
 *
 * Summary:
 *   This function takes the number of iterations from the input box, checks if it's a valid integer
 *   within the range of 0 to 10,000, and updates the lattice size and other properties based on the new
 *   iteration count. It also removes any existing buffers and modifies the cell size to fit the new lattice
 *   configuration. If the input is invalid, an error message is displayed.
 *
 * @returns {number} - Returns the updated number of iterations (addIterations).
 */
function setLatticeSize() {
  let newValue = parseInt(iterationInputBox.value); //Turns the iteration input to an integerpopTime
  if (!isNaN(newValue) &amp;&amp; newValue >= 0 &amp;&amp; newValue &lt;= 10000) {
    //Remove buffers if they existed.
    let newCellNum = latSize[0] - 2 * latSize[1];
    if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
      alterLatSize(newCellNum);
    } else {
      makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
    }
    //Alter cell size to accomodate for removed buffers
    let size = canvas.width / latSize[0];
    //Cells should have a maximum size of 45 :: This Caps cell size to 45
    if (size > 45) {
      size = 45;
    }
    alterSize(size);

    //Get rid of existing buffers but also change buffer size for when they are re-added.
    alterInf(inf[0], false, newValue);
    clear(latticeArray, true);
    addIterations = newValue; //updates the number of iterations
    makeLog("Iterations Set to " + newValue, logCanvas, messageQueue);
  } else {
    makeError("Invalid Iteration Size: " + iterationInputBox.value, logCanvas, messageQueue);
  }
  return addIterations;
}

/**
 * Clears all lattice arrays except the first and sets all cells to the "dead" state (white),
 * unless specified to retain the initial lattice configuration.
 *
 * Summary:
 *   This function clears the lattice, resetting it to the "dead" state (white) unless the `keepInit`
 *   flag is set to `true`, in which case the initial lattice state is preserved. It also clears all
 *   additional lattice arrays beyond the first, sets up the new lattice size, and updates the colors and
 *   borders of the cells. The function optionally restores the cell states from the initial lattice if
 *   `keepInit` is true. The canvas height is reset, and iteration counts are adjusted.
 *
 * @param {Array} latticeArray - The lattice array to be cleared.
 * @param {boolean} [keepInit=false] - Whether to keep the initial lattice configuration.
 */

function clear(latticeArray, keepInit = false) {
  totalDelta = 0;
  canvas.height = 400;
  alterNumOfIterations(1);
  alterCurrentIteration(1);
  let clearedLattice = new Array(new Array());
  alterNextLattice(new Array());
  let StartX = canvas.width / 2 - (latSize[0] * size) / 2;
  let neoLatticeArray = latticeArray;
  while (neoLatticeArray.length > 1) {
    neoLatticeArray.pop();
  }
  for (let i = 0; i &lt; latSize[0]; i++) {
    clearedLattice[0][i] = new cell(size, size, StartX + i * size, 0, 0);
    clearedLattice[0][i].setAliveColor(aliveColorSel.value);
    clearedLattice[0][i].setDeadColor(deadColorSel.value);
    clearedLattice[0][i].setAliveBorder(aliveBorderSel.value);
    clearedLattice[0][i].setDeadBorder(deadBorderSel.value);
  }

  let latPlusBufferArr = new Array();
  //If the clear is keeping the initial timesteps' cell states, push the color onto a mock array to save cell states.
  if (keepInit) {
    clearResetButton.innerHTML = "Clear";
    let bufferNum = (neoLatticeArray[0].length - clearedLattice[0].slice(0).length) / 2;
    for (let i = bufferNum; i &lt; latSize[0] + bufferNum; i++) {
      latPlusBufferArr.push(latticeArray[0][i].getColor());
    }
  }

  neoLatticeArray[0] = clearedLattice[0].slice(0);
  //If the clear is keeping the initial timesteps, flip the cell states according to the colors in the mock array.
  if (keepInit) {
    for (let i = 0; i &lt; latticeArray[0].length; i++) {
      if (latPlusBufferArr[i] == 1) {
        neoLatticeArray[0][i].flipColor();
      }
      neoLatticeArray[0][i].drawCell(ctx);
    }
  }
  alterLatticeArray(neoLatticeArray);
  alterCurrentLattice(latticeArray[0]);
  updateLattice();
}

/**
 * Takes the coordinates of a mouse click and calculates the corresponding cell in the lattice,
 * flipping or setting the color of the cell based on the click state.
 *
 * Summary:
 *   This function checks if a mouse click occurred within a cell's boundaries and then either flips
 *   the color of the cell or sets it to "alive" based on whether the mouse is being held down or not.
 *   It updates the lattice array to reflect the new state of the clicked cell(s) and redraws them on the canvas.
 *
 * @param {Array} latticeArray - The lattice array containing the cells.
 * @param {number} mouseX - The X-coordinate of the mouse click.
 * @param {number} mouseY - The Y-coordinate of the mouse click.
 */
function setCells(latticeArray, mouseX, mouseY) {
  let neoLatticeArray = latticeArray;
  if (latticeArray.length == 1) {
    for (let i = 0; i &lt; latticeArray[0].length; i++) {
      if (latticeArray[0][i].insideCell(mouseX, mouseY)) {
        if (!mouseDown) {
          neoLatticeArray[0][i].flipColor();
        } else {
          neoLatticeArray[0][i].setColor(1);
        }
      }
      neoLatticeArray[0][i].drawCell(ctx);
      alterLatticeArray(neoLatticeArray);
    }
  }
}

/**
 * Calculates the mouse position relative to the canvas element, accounting for various CSS styles.
 *
 * This function retrieves the position of the mouse click inside the canvas, adjusting for the canvas's
 * borders, padding, and scaling. It then returns the correct mouse coordinates within the canvas element
 * based on the current viewport and CSS styles.
 *
 * @param {MouseEvent} event - The mouse event triggered by the user's click.
 * @returns {number[]} An array containing the X and Y coordinates of the mouse click relative to the canvas.
 *                     The first element is the X-coordinate and the second is the Y-coordinate.
 */
function getMouseLocation(event) {
  //Gets the posistion of the edges of canvas
  let bounds = canvas.getBoundingClientRect();

  // Calculates Height and Width cooresponding to CSS setting of Canvas
  let cssWidth = parseFloat(getComputedStyle(canvas).getPropertyValue("width"));
  let cssHeight = parseFloat(getComputedStyle(canvas).getPropertyValue("height"));

  //Calculates the width of the thin border that wraps around the canvas allowing for pixel perfect clicking
  let borderWidth = parseInt(getComputedStyle(canvas).borderLeftWidth);

  //Gets the amount of padding which isnt generally considered in the mouse click
  let paddingLeft = parseFloat(getComputedStyle(canvas).paddingLeft);
  let paddingTop = parseFloat(getComputedStyle(canvas).paddingTop);

  //calculates mouse X and mouse Y of the Mouse during click and then distorts and move the location to where it needs cooresponding
  let mouseX = ((event.clientX - bounds.left - paddingLeft - borderWidth) * canvas.width) / cssWidth;
  let mouseY = ((event.clientY - bounds.top - paddingTop - borderWidth) * canvas.height) / cssHeight;

  return [mouseX, mouseY];
}

/**
 * Performs an iteration to update the lattice and number of iterations.
 *
 * This function adds new iterations to the lattice array and updates the displayed number of iterations.
 * It ensures the total iterations do not exceed a specified limit and updates the lattice visual representation.
 * The function operates with a short delay (5 milliseconds) to smooth the iteration process.
 *
 * @param {number} currentIteration - The current iteration count before this function is called.
 * @param {number} newIterations - The number of iterations to add in this call.
 * @returns {number} The value of `currentIteration`, indicating the iteration count before the update.
 */
function iterate(currentIteration, newIterations) {
  setTimeout(function () {
    if (numOfIterations + newIterations > addIterations) {
      alterNumOfIterations(addIterations + 1);
      run = 0;
    } else {
      alterNumOfIterations(numOfIterations + newIterations);
    }
    let neoLatticeArray = latticeArray;
    while (neoLatticeArray.length > numOfIterations) {
      neoLatticeArray.pop();
    }

    alterLatticeArray(neoLatticeArray);
    updateLattice();
    return currentIteration;
  }, 5);
}

/**
 * Stops the iteration process.
 *
 * If the `run` variable is set to 1 (indicating that iterations are running), this function will set it to 0,
 * effectively stopping any ongoing iterations.
 */
function stopIterating() {
  if (run) {
    run = 0;
  }
}

/**
 * Handles the toggling of the checkbox display and animation of the toggle button.
 *
 * When the toggle button is activated:
 * - The first checkbox is checked, and the second is unchecked.
 * - If the checkboxes are hidden, they are displayed, and the toggle button is animated to the right.
 * - If the checkboxes are already displayed, they are hidden, and the toggle button is animated back to the left.
 *
 * It also adjusts the lattice size and cell size according to the current settings, and clears the lattice.
 *
 * Updates the lattice to reflect either finite or infinite conditions based on the toggle state.
 *
 * @returns {void}
 */
export function toggleCheckbox() {
  // Set the first checkbox (not second checkbox) to be checked upon toggle button activation
  checkboxes[0].checked = true;
  checkboxes[1].checked = false;
  // If checkboxes are currently hidden (toggle bar was not active) display the checkboxes and animate toggle button
  if (periodicCheckBox.style.display == "none" || periodicCheckBox.style.display == "") {
    //Remove buffers if they exist.
    let newCellNum = latSize[0] - 2 * latSize[1];
    if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
      alterLatSize(newCellNum);
    } else {
      makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
    }
    //Alter cell size to accomodate removed buffers
    let size = canvas.width / latSize[0];
    //Cells should have a maximum size of 45 :: This Caps cell size to 45
    if (size > 45) {
      size = 45;
    }
    alterSize(size);
    alterInf(false);
    makeLog("Finite Condition Set", logCanvas, messageQueue);
    clear(latticeArray, true);
    periodicCheckBox.style.display = "block";
    nullCheckBox.style.display = "block";
    boundToggle.style.transform = "translateX(25px)"; // Move the toggle button to the right
    // If checkboxes are currently not hidden (toggle bar was active) hide the checkboxes and animate toggle button back
  } else {
    //Remove buffers if they exist.
    let newCellNum = latSize[0] - 2 * latSize[1];
    if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
      alterLatSize(newCellNum);
    } else {
      makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
    }
    //Alter cell size to accomodate removed buffers
    let size = canvas.width / latSize[0];
    //Cells should have a maximum size of 45 :: This Caps cell size to 45
    if (size > 45) {
      size = 45;
    }
    alterSize(size);
    //Settings changed to Infinite.
    alterInf(true);
    makeLog("Infinite Condition Set", logCanvas, messageQueue);
    clear(latticeArray, true);
    periodicCheckBox.style.display = "none";
    nullCheckBox.style.display = "none";
    boundToggle.style.transform = "translateX(0)"; // Move the toggle button back to the left
  }
}

/**
 * Handles the toggle functionality for the iteration option button.
 *
 * Toggles the button position between two states:
 * - When toggled on, moves the button to the right and logs "Iteration Box: On."
 * - When toggled off, returns the button to the left and logs "Iteration Box: Off."
 *
 * This function visually updates the toggle button's position and logs the current state.
 *
 * @returns {void}
 */

function iterationToggleOption() {
  // Toggle the position of the button
  if (iterationToggle.style.transform == "translateX(0px)") {
    iterationToggle.style.transform = "translateX(25px)";
    makeLog("Iteration Box: On", logCanvas, messageQueue);
  } else {
    iterationToggle.style.transform = "translateX(0px)";
    makeLog("Iteration Box: Off", logCanvas, messageQueue);
  }
}

/**
 * Toggles the cell border option on or off.
 *
 * Changes the toggle buttonâ€™s position and logs the current state:
 * - When toggled on, moves the button to the right and logs "Cell Border: On."
 * - When toggled off, returns the button to the left and logs "Cell Border: Off."
 *
 * This function visually updates the toggle button's position and logs the border setting.
 *
 * @returns {void}
 */
function borderToggleOption() {
  // Toggle the position of the button
  if (borderToggle.style.transform === "translateX(0px)") {
    borderToggle.style.transform = "translateX(25px)";
    makeLog("Cell Border: On", logCanvas, messageQueue);
  } else {
    borderToggle.style.transform = "translateX(0px)";
    makeLog("Cell Border: Off", logCanvas, messageQueue);
  }
}

/**
 * Toggles the Start/Stop button state and updates the GUI.
 *
 * - If the button is in the "Start" state and `run` is active, switches to "Stop" state:
 *   - Changes button text to "Stop."
 *   - Updates button appearance by swapping CSS classes.
 *   - Logs "Starting Iterations."
 *   - Adds buffers to the lattice.
 *
 * - If the button is in the "Stop" state and `run` is inactive, switches to "Start" state:
 *   - Changes button text to "Start."
 *   - Updates button appearance by swapping CSS classes.
 *   - Logs "Stopping Iterations."
 *
 * @returns {void}
 */

function startStopToggle() {
  // If the button is in start state, change it to stop state and vice versa
  if (startStopButton.classList.contains("start_button") &amp;&amp; run) {
    startStopButton.innerHTML = "Stop";
    startStopButton.classList.remove("start_button");
    startStopButton.classList.add("stop_button");
    makeLog("Starting Iterations", logCanvas, messageQueue);
    //Add buffers.
    alterInf(inf[0], true);
  } else if (startStopButton.classList.contains("stop_button") &amp;&amp; !run) {
    startStopButton.innerHTML = "Start";
    startStopButton.classList.remove("stop_button");
    startStopButton.classList.add("start_button");
    makeLog("Stopping Iterations", logCanvas, messageQueue);
  }
}

/**
 * Toggles the Clear/Reset button state and logs the appropriate message.
 *
 * - If the button text includes "Reset," changes the text to "Clear" and logs "Resetting Canvas."
 * - Otherwise, logs "Canvas Cleared."
 *
 * @returns {void}
 */
function clearResetToggle() {
  if (clearResetButton.innerHTML.includes("Reset")) {
    clearResetButton.innerHTML = "Clear";
    makeLog("Resetting Canvas", logCanvas, messageQueue);
  } else {
    makeLog("Canvas Cleared", logCanvas, messageQueue);
  }
}

/**
 * Sets the boundary condition based on the selected checkbox and ensures only one checkbox is checked at a time.
 *
 * - Stops ongoing iterations before changing boundary conditions.
 * - Enforces that only one checkbox can be checked:
 *     - If the first checkbox is selected, sets `boundaryCon` to 1 for a Periodic boundary condition, removes buffers if needed,
 *       adjusts lattice size, and logs the update.
 *     - If the second checkbox is selected, sets `boundaryCon` to 0 for a Null boundary condition, removes buffers if needed,
 *       adjusts lattice size, and logs the update.
 * - If neither checkbox is checked (attempted uncheck), rechecks the current checkbox to enforce one selection at all times.
 *
 * @returns {void}
 */
checkboxes.forEach(function (checkbox) {
  checkbox.addEventListener("change", function () {
    stopIterating(); // Stops the iteration before changing the finite boundary condition
    // Box is set to be checked upon change
    if (this.checked) {
      checkboxes.forEach(function (otherCheckbox) {
        // If one checkbox is already checked, uncheck the other checkbox
        if (otherCheckbox != checkbox) {
          otherCheckbox.checked = false;
        }
      });
      //If the first checkbox is selected, set the boundaryCon variable to 1 representing Periodic
      //boundary condition. Otherwise set boundaryCon to 0 representing Null.
      if (checkboxes[0].checked) {
        alterBoundaryCon(1);
        makeLog("Periodic Boundary Set", logCanvas, messageQueue);
        //Remove buffers if they exist.
        let newCellNum = latSize[0] - 2 * latSize[1];
        if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
          alterLatSize(newCellNum);
        } else {
          makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
        }
        //Alter size to accomodate removed buffers.
        let size = canvas.width / latSize[0];
        //Cells should have a maximum size of 45 :: This Caps cell size to 45
        if (size > 45) {
          size = 45;
        }
        alterSize(size);

        clear(latticeArray, true);
      } else {
        alterBoundaryCon(0);
        makeLog("Null Boundary Set", logCanvas, messageQueue);
        //Remove buffers if they exist.
        let newCellNum = latSize[0] - 2 * latSize[1];
        if (!isNaN(newCellNum) &amp;&amp; newCellNum >= 1 &amp;&amp; newCellNum &lt;= 1000) {
          alterLatSize(newCellNum);
        } else {
          makeError("Invalid Lattice Size: " + latticeSizeBox.value, logCanvas, messageQueue);
        }
        //Alter size to accomodate removed buffers.
        let size = canvas.width / latSize[0];
        //Cells should have a maximum size of 45 :: This Caps cell size to 45
        if (size > 45) {
          size = 45;
        }
        alterSize(size);

        clear(latticeArray, true);
      }
    }
    // Box is set to be unchecked: Don't allow ... one box must be checked at all times
    else {
      this.checked = true;
    }
  });
});

/**
 * Adds an error message to the log with red color to indicate an error.
 *
 * - Creates a new error log message with the specified `errorMessage`.
 * - Prepends this error message to the `messageQueue`.
 * - Displays the updated log.
 * - Optionally, a timer can be set to auto-remove old log entries (currently commented out).
 *
 * @param {string} errorMessage - The error message to display in the log.
 * @param {HTMLCanvasElement} logCanvas - The canvas element where the log messages are displayed.
 * @param {Array} messageQueue - An array of log messages to be displayed, where new messages are added to the start.
 * @returns {void}
 */
function makeError(errorMessage, logCanvas, messageQueue) {
  let tempLog = new logMessage(errorMessage, "red", logCanvas);
  messageQueue.unshift(tempLog);
  displayLog(messageQueue, logCanvas);
  //setPopLogTimer(messageQueue, logCanvas)
}

/**
 * Adds a general log message to the log with black color.
 *
 * - Creates a new log message with the specified `errorMessage`.
 * - Prepends this message to the `messageQueue`.
 * - Displays the updated log on the `logCanvas`.
 * - Optionally, a timer can be set to auto-remove old log entries (currently commented out).
 *
 * @param {string} errorMessage - The message to display in the log.
 * @param {HTMLCanvasElement} logCanvas - The canvas element where the log messages are displayed.
 * @param {Array} messageQueue - An array of log messages to be displayed, where new messages are added to the start.
 * @returns {void}
 */
function makeLog(errorMessage, logCanvas, messageQueue) {
  let tempLog = new logMessage(errorMessage, "black", logCanvas);
  messageQueue.unshift(tempLog);
  displayLog(messageQueue, logCanvas);
  //setPopLogTimer(messageQueue, logCanvas)
}

/**
 * Displays all log messages in the `messageQueue` on the specified `logCanvas`.
 *
 * - Clears the canvas by displaying a dummy message (e.g., "God Bless Ronald Reagan") in red.
 * - Iterates over `messageQueue`, rendering each message at its respective position.
 *
 * @param {Array} messageQueue - Array of log message objects to display, with each message shown in sequence.
 * @param {HTMLCanvasElement} logCanvas - The canvas element where log messages are rendered.
 * @returns {void}
 */
function displayLog(messageQueue, logCanvas) {
  let dummyMessage = new logMessage("God Bless Ronald Reagan", "red", logCanvas); //Message used to just clear canvas
  dummyMessage.clearCanvas();
  for (let i = 0; i &lt; messageQueue.length; i++) {
    messageQueue[i].displayMessage(i);
  }
}

/**
 * Captures the current canvas content and generates a PDF document upon clicking the "Download PDF" button.
 * - Retrieves image data from the canvas in PNG format.
 * - Creates a new PDF document sized to match the canvas dimensions.
 * - Adjusts the image's dimensions to maintain the canvas's aspect ratio, fitting it within the PDF page.
 * - Centers the image on the PDF page and saves the document with a name based on current iteration, rule number, and lattice size.
 * - Logs a message indicating the canvas was downloaded.
 *
 * @event click - Event listener for the "Download PDF" button.
 * @returns {void}
 */
downloadPDFButton.addEventListener("click", function () {
  let imgData = canvas.toDataURL("image/png"); // Get the image data from the canvas
  let pdf = new jsPDF("p", "pt", [canvas.width, canvas.height]); // Create a new PDF document with the canvas dimensions as page size

  // Calculate the aspect ratio of the canvas content
  let canvasAspectRatio = canvas.width / canvas.height;

  // Calculate the aspect ratio of the PDF page
  let pdfWidth = pdf.internal.pageSize.getWidth();
  let pdfHeight = pdf.internal.pageSize.getHeight();
  let pdfAspectRatio = pdfWidth / pdfHeight;

  // Default image dimensions with assumption that the canvas is taller than PDF page
  let imgWidth = pdfHeight * canvasAspectRatio;
  let imgHeight = pdfHeight;

  // Change size of the image in the PDF using the aspect ratios if canvas is wider than PDF page
  if (canvasAspectRatio > pdfAspectRatio) {
    imgWidth = pdfWidth;
    imgHeight = pdfWidth / canvasAspectRatio;
  }

  // Add the image to the PDF document and center it on the page
  let offsetX = (pdfWidth - imgWidth) / 2;
  let offsetY = (pdfHeight - imgHeight) / 2;
  pdf.addImage(imgData, "PNG", offsetX, offsetY, imgWidth, imgHeight);

  pdf.save("ParallelWNN" + "I" + numOfIterations + "R" + ruleNum + "L" + latSize[0] + ".pdf"); // Save the PDF
  makeLog("Downloaded Canvas", logCanvas, messageQueue);
});

/**
 * Captures the current canvas content and generates a downloadable PNG image upon clicking the "Download PNG" button.
 * - Retrieves image data from the canvas in PNG format.
 * - Creates a downloadable link using an anchor element and sets the file name based on current iteration, rule number, and lattice size.
 * - Triggers the download of the image and logs a message indicating the canvas was downloaded.
 *
 * @event click - Event listener for the "Download PNG" button.
 * @returns {void}
 */
downloadPNGButton.addEventListener("click", function () {
  let image = canvas.toDataURL(); // Get the image data from the canvas. Default is png
  let link = document.createElement("a"); // Create a new anchor element to create a downloadable link
  link.href = image; // Set the href attribute of the anchor element to the data URL of the image
  link.download = "ParallelWNN" + "I" + numOfIterations + "R" + ruleNum + "L" + latSize[0] + ".png"; // Set the filename
  link.click(); // Trigger a click on the anchor element to prompt the browser to download the image
  makeLog("Downloaded Canvas", logCanvas, messageQueue);
});

/* Handle open and closing of about window */
/**
 * Handles the opening of the "About" window when the About button is clicked.
 * - Sets the display style of the about window to "block", making it visible.
 *
 * @event click - Event listener for the "About" button.
 * @returns {void}
 */
aboutButton.addEventListener("click", function () {
  aboutWindow.style.display = "block";
});

/**
 * Handles the closing of the "About" window when the close button (x) is clicked.
 * - Sets the display style of the about window to "none", hiding it.
 *
 * @event click - Event listener for the close button in the "About" window.
 * @returns {void}
 */
closeAbout.addEventListener("click", function () {
  aboutWindow.style.display = "none";
});

/**
 * Closes the "About" window if any area outside of it is clicked.
 * - If the click event target is the about window itself (excluding the content area),
 *   the window is hidden by setting its display style to "none".
 *
 * @event click - Event listener for clicks anywhere on the window.
 * @param {Event} event - The click event object.
 * @returns {void}
 */
window.addEventListener("click", function (event) {
  // Check if about window is mouse target (outside text frame was clicked) and, if so, hide about window
  if (event.target == aboutWindow) {
    aboutWindow.style.display = "none";
  }
});

/* Handle open and closing of options window */

/**
 * Toggles the visibility of the options window when the options button is clicked.
 * - If the options window is currently visible, it will be hidden.
 * - If the options window is currently hidden, it will be displayed.
 *
 * @event click - Event listener for the click event on the options button.
 * @returns {void}
 */
optionsButton.addEventListener("click", function () {
  // If options window is displayed, hide it; if hidden, display it
  if (optionsWindow.style.display == "block") {
    optionsWindow.style.display = "none";
  } else {
    optionsWindow.style.display = "block";
  }
});

/**
 * Closes the options window when the close (X) button in the top right of the window is clicked.
 *
 * @event click - Event listener for the click event on the close button of the options window.
 * @returns {void}
 */
closeOptions.addEventListener("click", function () {
  optionsWindow.style.display = "none";
});

/**
 * Updates the displayed iteration speed value and adjusts the iteration delay when the slider value changes.
 *
 * @event input - Event listener for the input event on the iteration speed slider.
 * @this {HTMLInputElement} - The slider element, from which the current value is retrieved.
 * @returns {void}
 */
iterationSpeedSlider.oninput = function () {
  iterationSpeedValue.innerHTML = this.value;
  setDelay(this.value);
};

/**
 * Creates a debounced version of a function, ensuring it is called only after a delay
 * once the event handler stops being triggered.
 *
 * @param {Function} callback - The function to be executed after the debounce delay.
 * @returns {Function} A debounced version of the provided callback function.
 *
 * @example
 * const debouncedFunction = debounce(function() {
 *   console.log('Executed after delay');
 * });
 * window.addEventListener('resize', debouncedFunction);
 */
function debounce(callback) {
  let timeoutId;

  return function (event) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback(event); // Directly pass the event object to the callback function
    }, 25);
  };
}

/**
 * Creates a debounced version of a function optimized for quick actions (e.g., slider input),
 * ensuring it is called only after a brief delay once the event handler stops being triggered.
 * This is particularly useful when updating a temporary array before the next cell can be clicked.
 *
 * @param {Function} callback - The function to be executed after the debounce delay.
 * @returns {Function} A debounced version of the provided callback function.
 *
 * @example
 * const debouncedSlider = shortDebounce(function(event) {
 *   console.log('Slider value changed:', event.target.value);
 * });
 * slider.addEventListener('input', debouncedSlider);
 */
function shortDebounce(callback) {
  let timeoutId;

  return function (event) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback(event); // Directly pass the event object to the callback function
    }, 5);
  };
}

// Initialize toggle buttons to x position 0px to enable x translation in functions
iterationToggle.style.transform = "translateX(0px)";
borderToggle.style.transform = "translateX(0px)";

// Display initial iteration count to HTML page
outputIteration.innerHTML = "Iteration Count: 0";

// Set the default iteration speed value and display it
iterationSpeedValue.innerHTML = 750;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="%252525252520Parameters.html">- Parameters</a></li><li><a href="cell.html">cell</a></li><li><a href="logMessage.html">logMessage</a></li></ul><h3>Events</h3><ul><li><a href="document.html#event:DOMContentLoaded">DOMContentLoaded</a></li><li><a href="global.html#event:click-Eventlistenerforclicksanywhereonthewindow.">click - Event listener for clicks anywhere on the window.</a></li><li><a href="global.html#event:click-Eventlistenerforthe%2522About%2522button.">click - Event listener for the "About" button.</a></li><li><a href="global.html#event:click-Eventlistenerforthe%2522DownloadPDF%2522button.">click - Event listener for the "Download PDF" button.</a></li><li><a href="global.html#event:click-Eventlistenerforthe%2522DownloadPNG%2522button.">click - Event listener for the "Download PNG" button.</a></li><li><a href="global.html#event:click-Eventlistenerfortheclickeventontheclosebuttonoftheoptionswindow.">click - Event listener for the click event on the close button of the options window.</a></li><li><a href="global.html#event:click-Eventlistenerfortheclickeventontheoptionsbutton.">click - Event listener for the click event on the options button.</a></li><li><a href="global.html#event:click-Eventlistenerfortheclosebuttoninthe%2522About%2522window.">click - Event listener for the close button in the "About" window.</a></li><li><a href="global.html#event:input-Eventlistenerfortheinputeventontheiterationspeedslider.">input - Event listener for the input event on the iteration speed slider.</a></li></ul><h3>Global</h3><ul><li><a href="global.html#LatticeDisplay">LatticeDisplay</a></li><li><a href="global.html#aboutButton">aboutButton</a></li><li><a href="global.html#aboutWindow">aboutWindow</a></li><li><a href="global.html#activateSetup">activateSetup</a></li><li><a href="global.html#addIterations">addIterations</a></li><li><a href="global.html#aliveBorderSel">aliveBorderSel</a></li><li><a href="global.html#aliveColorSel">aliveColorSel</a></li><li><a href="global.html#alterBorder">alterBorder</a></li><li><a href="global.html#alterBoundaryCon">alterBoundaryCon</a></li><li><a href="global.html#alterCell">alterCell</a></li><li><a href="global.html#alterCurrentIteration">alterCurrentIteration</a></li><li><a href="global.html#alterCurrentLattice">alterCurrentLattice</a></li><li><a href="global.html#alterInf">alterInf</a></li><li><a href="global.html#alterLatSize">alterLatSize</a></li><li><a href="global.html#alterLattice">alterLattice</a></li><li><a href="global.html#alterLatticeArray">alterLatticeArray</a></li><li><a href="global.html#alterNeighborCount">alterNeighborCount</a></li><li><a href="global.html#alterNextLattice">alterNextLattice</a></li><li><a href="global.html#alterNumOfIterations">alterNumOfIterations</a></li><li><a href="global.html#alterOrder">alterOrder</a></li><li><a href="global.html#alterRule">alterRule</a></li><li><a href="global.html#alterRuleNum">alterRuleNum</a></li><li><a href="global.html#alterSetup">alterSetup</a></li><li><a href="global.html#alterSize">alterSize</a></li><li><a href="global.html#alterTempOrder">alterTempOrder</a></li><li><a href="global.html#border">border</a></li><li><a href="global.html#borderToggle">borderToggle</a></li><li><a href="global.html#borderToggleButton">borderToggleButton</a></li><li><a href="global.html#borderToggleOption">borderToggleOption</a></li><li><a href="global.html#boundToggle">boundToggle</a></li><li><a href="global.html#boundToggleButton">boundToggleButton</a></li><li><a href="global.html#boundaryCollide">boundaryCollide</a></li><li><a href="global.html#boundaryCon">boundaryCon</a></li><li><a href="global.html#bounds">bounds</a></li><li><a href="global.html#buffer">buffer</a></li><li><a href="global.html#bufferArray">bufferArray</a></li><li><a href="global.html#build101">build101</a></li><li><a href="global.html#build119">build119</a></li><li><a href="global.html#build1234">build1234</a></li><li><a href="global.html#build295">build295</a></li><li><a href="global.html#build60P">build60P</a></li><li><a href="global.html#buildAK94">buildAK94</a></li><li><a href="global.html#buildGlider">buildGlider</a></li><li><a href="global.html#buildGtoG">buildGtoG</a></li><li><a href="global.html#buildSnail">buildSnail</a></li><li><a href="global.html#buildTrigger">buildTrigger</a></li><li><a href="global.html#buildTub">buildTub</a></li><li><a href="global.html#canvas">canvas</a></li><li><a href="global.html#canvasHeight">canvasHeight</a></li><li><a href="global.html#canvasWidth">canvasWidth</a></li><li><a href="global.html#cellSize">cellSize</a></li><li><a href="global.html#centerOut">centerOut</a></li><li><a href="global.html#centerOutR">centerOutR</a></li><li><a href="global.html#changeNeighbor">changeNeighbor</a></li><li><a href="global.html#checkboxes">checkboxes</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clearResetButton">clearResetButton</a></li><li><a href="global.html#clearResetToggle">clearResetToggle</a></li><li><a href="global.html#closeAbout">closeAbout</a></li><li><a href="global.html#closeHelp">closeHelp</a></li><li><a href="global.html#closeLibrary">closeLibrary</a></li><li><a href="global.html#closeOptions">closeOptions</a></li><li><a href="global.html#continouslyIterate">continouslyIterate</a></li><li><a href="global.html#createInit">createInit</a></li><li><a href="global.html#createNewConfig">createNewConfig</a></li><li><a href="global.html#createOrderInitializesandpopulatestheorderArraywithvaluesfrom0tolatSize-1forthepurposeofcontrollingtheorderofoperations.">createOrderInitializes and populates the orderArray with values from 0 to latSize-1 for the purpose of controlling the order of operations.</a></li><li><a href="global.html#createVis">createVis</a></li><li><a href="global.html#createVisInit">createVisInit</a></li><li><a href="global.html#ctx">ctx</a></li><li><a href="global.html#currentDelay">currentDelay</a></li><li><a href="global.html#currentIteration">currentIteration</a></li><li><a href="global.html#currentLattice">currentLattice</a></li><li><a href="global.html#currentReset">currentReset</a></li><li><a href="global.html#deadBorderSel">deadBorderSel</a></li><li><a href="global.html#deadColorSel">deadColorSel</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#displayLattice">displayLattice</a></li><li><a href="global.html#displayLog">displayLog</a></li><li><a href="global.html#displayWelcome">displayWelcome</a></li><li><a href="global.html#downloadPDFButton">downloadPDFButton</a></li><li><a href="global.html#downloadPNGButton">downloadPNGButton</a></li><li><a href="global.html#drawLattice">drawLattice</a></li><li><a href="global.html#edgesIn">edgesIn</a></li><li><a href="global.html#edgesInR">edgesInR</a></li><li><a href="global.html#generateLattice">generateLattice</a></li><li><a href="global.html#getBorder">getBorder</a></li><li><a href="global.html#getMouseLocation">getMouseLocation</a></li><li><a href="global.html#getSetup">getSetup</a></li><li><a href="global.html#helpButton">helpButton</a></li><li><a href="global.html#helpWindow">helpWindow</a></li><li><a href="global.html#inLattice">inLattice</a></li><li><a href="global.html#inf">inf</a></li><li><a href="global.html#intialCanvas">intialCanvas</a></li><li><a href="global.html#iterate">iterate</a></li><li><a href="global.html#iterateButton">iterateButton</a></li><li><a href="global.html#iterationCount">iterationCount</a></li><li><a href="global.html#iterationInputBox">iterationInputBox</a></li><li><a href="global.html#iterationSpeedSlider">iterationSpeedSlider</a></li><li><a href="global.html#iterationSpeedValue">iterationSpeedValue</a></li><li><a href="global.html#iterationSubmit">iterationSubmit</a></li><li><a href="global.html#iterationTime">iterationTime</a></li><li><a href="global.html#iterationToggle">iterationToggle</a></li><li><a href="global.html#iterationToggleButton">iterationToggleButton</a></li><li><a href="global.html#iterationToggleOption">iterationToggleOption</a></li><li><a href="global.html#latSize">latSize</a></li><li><a href="global.html#latticeArray">latticeArray</a></li><li><a href="global.html#latticeFillButton">latticeFillButton</a></li><li><a href="global.html#latticeSizeBox">latticeSizeBox</a></li><li><a href="global.html#latticeSizeSubmit">latticeSizeSubmit</a></li><li><a href="global.html#lctx">lctx</a></li><li><a href="global.html#left2right">left2right</a></li><li><a href="global.html#libraries">libraries</a></li><li><a href="global.html#library101">library101</a></li><li><a href="global.html#library119P4H1V0">library119P4H1V0</a></li><li><a href="global.html#library1234">library1234</a></li><li><a href="global.html#library295P5H1V1">library295P5H1V1</a></li><li><a href="global.html#library4gto5gReaction">library4gto5gReaction</a></li><li><a href="global.html#library60P312">library60P312</a></li><li><a href="global.html#libraryAK94Gun">libraryAK94Gun</a></li><li><a href="global.html#libraryButton">libraryButton</a></li><li><a href="global.html#librarySnail">librarySnail</a></li><li><a href="global.html#libraryTrigger">libraryTrigger</a></li><li><a href="global.html#libraryTubstretcher">libraryTubstretcher</a></li><li><a href="global.html#libraryWindow">libraryWindow</a></li><li><a href="global.html#logCanvas">logCanvas</a></li><li><a href="global.html#makeError">makeError</a></li><li><a href="global.html#makeLog">makeLog</a></li><li><a href="global.html#makeTickBox">makeTickBox</a></li><li><a href="global.html#messageQueue">messageQueue</a></li><li><a href="global.html#mouseDown">mouseDown</a></li><li><a href="global.html#mouseXPos">mouseXPos</a></li><li><a href="global.html#mouseYPos">mouseYPos</a></li><li><a href="global.html#nInputBox">nInputBox</a></li><li><a href="global.html#nSkip">nSkip</a></li><li><a href="global.html#nSubmit">nSubmit</a></li><li><a href="global.html#nextLattice">nextLattice</a></li><li><a href="global.html#nullCheckBox">nullCheckBox</a></li><li><a href="global.html#numOfIterations">numOfIterations</a></li><li><a href="global.html#optionsButton">optionsButton</a></li><li><a href="global.html#optionsWindow">optionsWindow</a></li><li><a href="global.html#outputIteration">outputIteration</a></li><li><a href="global.html#periodicCheckBox">periodicCheckBox</a></li><li><a href="global.html#randOrder">randOrder</a></li><li><a href="global.html#randomFillButton">randomFillButton</a></li><li><a href="global.html#recountNeighbors">recountNeighbors</a></li><li><a href="global.html#redrawLattice">redrawLattice</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetLattice">resetLattice</a></li><li><a href="global.html#reverse">reverse</a></li><li><a href="global.html#revertCells">revertCells</a></li><li><a href="global.html#right2left">right2left</a></li><li><a href="global.html#rule">rule</a></li><li><a href="global.html#ruleInputBox">ruleInputBox</a></li><li><a href="global.html#ruleNum">ruleNum</a></li><li><a href="global.html#ruleNumToRule">ruleNumToRule</a></li><li><a href="global.html#ruleSubmit">ruleSubmit</a></li><li><a href="global.html#run">run</a></li><li><a href="global.html#saveReset">saveReset</a></li><li><a href="global.html#scale">scale</a></li><li><a href="global.html#scribble">scribble</a></li><li><a href="global.html#setCells">setCells</a></li><li><a href="global.html#setDelay">setDelay</a></li><li><a href="global.html#setLattice">setLattice</a></li><li><a href="global.html#setLatticeSize">setLatticeSize</a></li><li><a href="global.html#setN">setN</a></li><li><a href="global.html#setRule">setRule</a></li><li><a href="global.html#setupButton">setupButton</a></li><li><a href="global.html#setupItems">setupItems</a></li><li><a href="global.html#shift">shift</a></li><li><a href="global.html#shiftX">shiftX</a></li><li><a href="global.html#shiftY">shiftY</a></li><li><a href="global.html#shortDebounce">shortDebounce</a></li><li><a href="global.html#simulateButton">simulateButton</a></li><li><a href="global.html#size">size</a></li><li><a href="global.html#skip">skip</a></li><li><a href="global.html#standardItems">standardItems</a></li><li><a href="global.html#startStopButton">startStopButton</a></li><li><a href="global.html#startStopToggle">startStopToggle</a></li><li><a href="global.html#stopIterating">stopIterating</a></li><li><a href="global.html#tctx">tctx</a></li><li><a href="global.html#tickCanvas">tickCanvas</a></li><li><a href="global.html#tickerToggle">tickerToggle</a></li><li><a href="global.html#toggleCheckbox">toggleCheckbox</a></li><li><a href="global.html#totalDelta">totalDelta</a></li><li><a href="global.html#updateLattice">updateLattice</a></li><li><a href="global.html#updateLatticeUpdatesthesimulationbygeneratingthenexttimesteplatticeforeachiteration,applyingthecurrentruleandboundarycondition,andthenredrawingtheupdatedlatticeonthecanvas.">updateLatticeUpdates the simulation by generating the next timestep lattice for each iteration, applying thecurrent rule and boundary condition, and then redrawing the updated lattice on the canvas.</a></li><li><a href="global.html#updateLatticeSize">updateLatticeSize</a></li><li><a href="global.html#updateOutput">updateOutput</a></li><li><a href="global.html#visBounds">visBounds</a></li><li><a href="global.html#visLatticeArray">visLatticeArray</a></li><li><a href="global.html#visLatticeHeight">visLatticeHeight</a></li><li><a href="global.html#visLatticeWidth">visLatticeWidth</a></li><li><a href="global.html#voidButton">voidButton</a></li><li><a href="global.html#xCenter">xCenter</a></li><li><a href="global.html#yCenter">yCenter</a></li><li><a href="global.html#zoomSlider">zoomSlider</a></li><li><a href="global.html#zoomValue">zoomValue</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Nov 10 2024 02:41:34 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
